首先看问题（答案见后面）


1、变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？
---
A.1
B.-1
C.263+262+…+22+21+2^0
D.–(263+262+…+22+21+2^0)




2、TCP建立连接的三次握手中，第二次握手发送的包会包含的标记，最正确的描述是？
---
A.ACK
B.SYN,ACK
C.SYN,PSH
D.SYN

3、栈是先进后出的数据结构。给定一个大小为3的初始状态为空的栈，已知一组数据经过这个栈后，最终的数据顺序依次为：1 3 2 4 ，问原始的进栈数据不可能是以下的那组?
---
A.2 3 1 4
B.1 4 2 3
C.4 2 3 1
D.3 1 2 4

4、电路中其中三个门电路非门，与门，或门的示意图及性质分别如下所示：
非门，使输入的电平编程相反电平：
 
与门，使输入两个高电平，输出高电平，其他情况下输出低电平：
 
或门。当且仅当输入两个低电平时，输出低电平，否则输出高电平：
 
现在对以下的电路中的 A 和 B 引脚分别持续输入一个高电平（ 1 ）和一个低电平（ 0 ），问最终电路的引脚 C 、 D 、 E 、 F 分别输出的电平是什么？
 
A.C=0,D=1,E=0,F=1
B.C=1,D=1,E=1,F=0
C.C=1,D=1,E=0,F=1
D.C=0,D=0,E=0,F=1

5、操作系统中可以使用LRU(least recently used)内存淘汰旧数据的策略，如果内存需要加载新数据但空间又不足，则会按照最近访问时间进行排序，并将最老的数据淘汰，假设现在内存空间大小为5，原本内存中没有数据，对内存中数据的访问顺序如下：1,2,5,3,4,6,1,4,3,6,7,8,3,9
---
A.缺页次数：9
B.缺页次数：4
C.缺页次数：10
D.缺页次数：5

6、下面的程序中， int32-t 表示一个有符号的 32 位整数，程序的入口是 main 函数，问最终 res 的结果是多少？
---
A.–(231+230+…+22+21+2^0)
B.0
C.-1
D.程序会死循环

7、给定一个如下所示的图，图中的边代表了两个节点间的距离。如果使用迪杰斯特拉算法对节点 1 和节点 8 求最短路径，则当完成计算时，算得节点1 到节点 8 的最短路径是？同时当完成节点 1 到节点 8 的最短路径计算时，节点 1 到哪些节点（除了 1 和 8 ）的最短路径也已经计算完毕？（　）

 

8、x86 CPU在实模式下解释代码时看到一个地址为2330H:5041H,请问它最终在内存中要找的地址是多少？

A.28341H
B.5374H
C.52740H
D.7371H

9、有三个程序Ｊ１，Ｊ２，Ｊ３。程序在单核ＣＰＵ执行时，三个程序需要的资源如下所示：
 
优先级高的程序可以抢占优先级低的程序的ＣＰＵ，但不能抢占ＩＯ。问当所有任务执行完毕时，共消耗的时间是？

A.170ｍｓ
B.160ｍｓ
C.120ｍｓ
D.130ｍｓ

10、给定整数m以及n各数字A1,A2,…An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果，请求出这些结果中大于m的有多少个。

答案仅供参考

1、答案解析：正确答案: B  
（1）a+b的16进制表示为：OxFFFFFFFFFFFFFFF（16位F），转为2进制为111……111（64位1，每个F->4位2）。
（2）有符号数：是针对二进制来讲的。用最高位作为符号位，“0”代表“+”，“1”代表“-”。所以a+b的结果是一个负数。
（3）计算机中负数是以补码的形式保存的，将补码转换成原码的计算方式如下：
        ①. 对于正数，原码与补码相同。
        ②.对于负数，将补码除符号位之外，按位取反，末位加1，即得到原码。
（4）a + b = 111……111（64位1）
          取反：100……000（1位1，后面63位0）
          加一：100……00（中间62位0）
      10进制：-1。

2、答案解析：正确答案: B
附上tcp建立连接的三次握手过程图（第二次握手包含的标记是SYN，ACK），所以选B：
 


3、答案解析：正确答案: C
注意栈的大小为3

4、答案解析：正确答案: D

5、答案解析：正确答案: C  
内存空间5，所以前5个都是缺页的，因为内存空间中并没有这五个，然后6置换1，1置换2，然后4.3.6都有不用置换，7置换5，8置换4，3有了，然后9置换3，总共十次。

6、答案解析：正确答案: D
以char为例
f(1,0): 
        a=2  b=-1 
        a=3  b=-2 
        … 
        a=127 b=-126 
        a=128 b=-127  溢出–>a=-128 b=-127     char范围:-128~127        
 return a+b:-128-127实际上是1(char范围)，继续循环

而原例为int_32t,临界情况 a+b:      -232+(-232+1)=1,也继续循环。

因此死循环。

7、答案解析：正确答案: C
初始状态：路径长度0：（1）
路径长度1：（1,5）
路径长度2：（1,3）
路径长度3：（1,3,4），（1,2）
路径长度4：（1,5,8）
节点1到8的最短路径长度为4；    2，3,4,5节点的最短路径已经计算完毕；  其中到5节点的最短路径最小为1；
应该选C，感觉出题人玩文字游戏把自己绕进去了

8、答案解析：正确答案: A
实模式下内存空间的访问
8086处理器（CPU）内的寄存器都是16位的，地址线上的地址由CPU提供。CPU用两个16位的值合成一个20位的值：将一个16位的值乘以16（相当于这个16位的值保存在20位寄存器的低16位中，然后将低16位往高位移动了4位）再加上另一个16位的值。将这个由2个16位合成的值提供给20根地址线作为访问内存的地址值。被乘以16的那个值被称为段基址，没有被乘以16的那个值被称为偏移地址。

CPU在实模式下，段寄存器中的值就是段基址，如果想要通过汇编程序访问某个内存单元，那么就需要指定一个段寄存器和一个偏移地址或以“段基址值：偏移地址值”的格式。CPU会将段寄存器的值乘以16再与偏移地址相加后，才将这个结果提供给地址线;用段基址和偏移地址的形式给出的表达式，CPU也会给段基址乘以16与偏移地址相加后，才将这个结果提供给地址线。

Figure 2. 实模式下访问内存（得出内存地址）的方式
这就是说，在汇编程序中，得用段基址：偏移地址的方式访问内存，因为CPU形成内存地址的方式是“段基址* 16 + 偏移地址”。
按照“段：偏移地址”的方式访问内存是CPU对内存的一种管理方式

9、答案解析：正确答案: D
因为优先级高的程序可以抢占优先级低的程序的ＣＰＵ，但不能抢占ＩＯ，
所以J1在CPU之后不能抢占J2的IO，J2在IO之后可以抢占J3的CPU。

CPU：J1 40ms + J3 10ms + J2 20ms +J1 20ms
IO：J2 50ms + J1 60ms + J3 20ms

所以共消耗时间为130ms，选D。

10、答案解析：
直接计算肯定是超时的，所以这问题不能使用暴力破解，考虑到从高位到地位，依次进行位运算，如果两个数异或结果在某高位为1，而m的对应位为0，则肯定任何这两位异或结果为1的都会比m大。

由此，考虑使用字典树（TrieTree）从高位到第位建立字典，再使用每个元素依次去字典中查对应高位异或为1， 而m为0的数的个数，相加在除以2既是最终的结果；直接贴出代码如下，非原创，欢迎讨论；

补充：queryTrieTree在搜索的过程中，是从高位往低位搜索，那么，如果有一个数与字典中的数异或结果的第k位大于m的第k位，那么该数与对应分支中所有的数异或结果都会大于m， 否则，就要搜索在第k位异或相等的情况下，更低位的异或结果。queryTrieTree中四个分支的作用分别如下：

aDigit=1， mDigit=1时，字典中第k位为0，异或结果为1，需要继续搜索更低位，第k位为1，异或结果为0，小于mDigit，不用理会；

aDigit=0， mDigit=1时，字典中第k位为1，异或结果为1，需要继续搜索更低位，第k位为0，异或结果为0，小于mDigit，不用理会；

aDigit=1， mDigit=0时，字典中第k位为0，异或结果为1，与对应分支所有数异或，结果都会大于m，第k位为1，异或结果为0，递归获得结果；

aDigit=0， mDigit=0时，字典中第k位为1，异或结果为1，与对应分支所有数异或，结果都会大于m，第k位为0，异或结果为0，递归获得结果；







